
Voici comment on peut exécuter une simple commande UNIX
en utilisant execve() dans un programme.

#include <unistd.h>
#include <stdio.h>

int main()
{
    char const  *args[] = { "ls", NULL }; // the command
    char const  *envp[] = { NULL }; // env.
    execve("/usr/bin/ls", args, envp); // execute command at the path.
    perror("execve");
    return (1);
}

Différence entre : char const *args[] & char *const args[]
char const *args[] :
- le modificateur const est appliqué au pointeur 
lui-même, ce qui signifie que le pointeur est constant, c'est-à-dire qu'il 
ne peut pas être modifié pour pointer vers une autre adresse mémoire. 
- Cependant, les données vers lesquelles il pointe peuvent être modifiées.
Ainsi, dans ce cas, vous pouvez modifier les éléments du tableau args 
pour pointer vers d'autres chaînes de caractères, mais vous ne pouvez 
pas modifier les chaînes de caractères elles-mêmes une fois qu'elles sont définies.

char *const args[] :
- le modificateur const est appliqué aux données vers lesquelles le pointeur pointe, 
c'est-à-dire aux chaînes de caractères elles-mêmes. 
Cela signifie que les données pointées par le pointeur sont constantes et ne peuvent pas être modifiées.
- En revanche, le pointeur lui-même peut être modifié pour pointer vers une autre 
adresse mémoire, car il n'est pas constant.
- On peut modifier les données pointées par chaque élement du tab.
- On peut modifier les adresses mémoire pointées par chq élément du tab.
- On ne peut pas modifier par contre la chaîne vers laquelle il pointe.

int main()
{
    printf("PID before the execve is: %d\n", getpid());
    char *const  args[] = { "ls", NULL }; // the command
    char *const  envp[] = { NULL }; // env.
    execve("/usr/bin/ls", args, envp); // execute command at the path.
    perror("execve");
    printf("PID AFTER the execve is: %d\n", getpid()); // Why is this not getting printed ?
    return (1);
}

Analysons ce qui se passe en détail :

1. Affichage du PID avant execve() :
- La ligne printf("PID before the execve is: %d\n", getpid()); affiche le PID 
(identifiant de processus) du processus en cours d'exécution avant l'appel à execve().
- Cette ligne est exécutée normalement et affiche le PID du processus parent 
avant l'exécution de execve().

2. Définition des tableaux d'arguments et d'environnement :
- Les tableaux args et envp sont définis pour contenir les arguments de 
la commande et les variables d'environnement, respectivement.
- Dans ce cas, args contient simplement la commande "ls", et envp est 
un tableau vide car aucune variable d'environnement n'est passée à la commande.

3. Appel à la fonction execve() :
- execve("/usr/bin/ls", args, envp); est appelé pour exécuter la commande ls 
à partir du chemin spécifié avec les arguments et les variables d'environnement fournis.
- Une fois que execve() est appelé, le processus courant est remplacé par la commande ls. 
Cela signifie que le reste du code dans la fonction main() n'est pas exécuté.

4. Gestion des erreurs :
- Si execve() échoue, l'appel à perror("execve"); affichera un message d'erreur 
approprié sur la sortie d'erreur standard.
- Cependant, dans ce cas, si execve() réussit, le code suivant ne sera pas exécuté, 
y compris l'appel à perror().

5. Affichage du PID après execve() :
- La ligne printf("PID AFTER the execve is: %d\n", getpid()); ne sera pas exécutée 
car le processus courant a été remplacé par la commande ls après l'appel à execve().
- Par conséquent, le PID après l'exécution de execve() serait celui du processus ls, 
pas celui du processus parent, mais puisque le code n'est pas exécuté, cela n'est pas affiché.
- execve() remplace le processus appelant par le programme spécifié. 
Cela signifie que le processus en cours d'exécution (dans ce cas, le processus principal du programme C) 
est terminé et remplacé par le programme ls.
- Après que execve() est appelé avec succès, le reste du code dans la fonction main() n'est pas exécuté, 
car le processus a été remplacé et le contrôle est passé à ls.

En résumé, le deuxième printf() n'est pas affiché car le processus courant est remplacé 
par la commande ls après l'appel à execve(), et le reste du code dans la fonction main() 
n'est pas exécuté.
En fait, une fois que le processus enfant a exécuté le prog. spécifié (execve), le processus parent (shell)
doit reprendre le contrôle donc la suite du prog. n'est pas réalisé.
